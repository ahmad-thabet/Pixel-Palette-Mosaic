<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>1M Follower Pixels</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      background: #0f0f0f;
      overflow: hidden;
      font-family: monospace;
    }

    #canvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      cursor: grab;
      touch-action: none;
    }

    #canvas:active {
      cursor: grabbing;
    }

    #info {
      position: fixed;
      top: 12px;
      left: 12px;
      background: rgba(0, 0, 0, 0.8);
      color: #0f0;
      padding: 12px 16px;
      border: 2px solid #0f0;
      font-size: 12px;
      line-height: 1.6;
      pointer-events: none;
      z-index: 100;
    }

    #hover-info {
      position: fixed;
      background: rgba(0, 0, 0, 0.9);
      color: #0f0;
      padding: 8px 12px;
      border: 1px solid #0f0;
      font-size: 11px;
      pointer-events: none;
      display: none;
      z-index: 101;
      white-space: nowrap;
    }

    #controls {
      position: fixed;
      bottom: 12px;
      right: 12px;
      background: rgba(0, 0, 0, 0.8);
      color: #0f0;
      padding: 8px 12px;
      border: 1px solid #0f0;
      font-size: 11px;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="info">
    <div id="pixel-count">Loading...</div>
    <div id="loaded-users"></div>
    <div id="last-updated"></div>
  </div>
  <div id="hover-info"></div>
  <div id="controls">
    <div>Scroll: Zoom | Drag: Pan | Hover: User Info | Click: Profile</div>
  </div>

  <script>
    // ============ Configuration ============
    const GRID_SIZE = 1000;
    const PIXEL_SIZE = 1;
    const ANIMATION_SPEED = 1000; // Pixels to draw per second
    const SEED = 42;

    // ============ Seeded Random Number Generator ============
    function mulberry32(a) {
      return function() {
        a |= 0;
        a = (a + 0x6d2b79f5) | 0;
        let t = Math.imul(a ^ (a >>> 15), 1 | a);
        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    // ============ Canvas Setup ============
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    const offscreen = document.createElement('canvas');
    offscreen.width = GRID_SIZE;
    offscreen.height = GRID_SIZE;
    const offscreenCtx = offscreen.getContext('2d');

    // ============ State ============
    let users = [];
    let pixelList = [];
    let pixelMap = new Map(); // For hover detection: "x,y" -> user object
    let drawnPixelCount = 0;
    let totalPixels = 0;
    let isAnimating = false;
    let lastUpdated = '';

    // View state
    let scale = 1;
    let panX = 0;
    let panY = 0;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;

    // Animation timing
    let lastFrameTime = performance.now();

    // ============ Pixel Generation ============
    function generatePixelPositions(count) {
      const rng = mulberry32(SEED);
      const occupiedSet = new Set();
      pixelList = [];
      pixelMap.clear();

      for (let i = 0; i < count && i < users.length; i++) {
        let attempts = 0;
        const maxAttempts = 1000;

        while (attempts < maxAttempts) {
          const x = Math.floor(rng() * GRID_SIZE);
          const y = Math.floor(rng() * GRID_SIZE);
          const key = `${x},${y}`;

          if (!occupiedSet.has(key)) {
            occupiedSet.add(key);
            const user = users[i];
            pixelList.push({ x, y, user, imageData: null, loaded: false });
            pixelMap.set(key, user);
            break;
          }
          attempts++;
        }
      }

      totalPixels = pixelList.length;
      console.log(`Generated ${totalPixels} pixel positions for users`);
    }

    // ============ Image Loading ============
    function loadUserImages() {
      const loadPromises = pixelList.map((pixel, index) => {
        return new Promise((resolve) => {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
            // Draw to a small canvas to get pixel data
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 1;
            tempCanvas.height = 1;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(img, 0, 0, 1, 1);
            const imageData = tempCtx.getImageData(0, 0, 1, 1).data;
            pixel.imageData = Array.from(imageData);
            pixel.loaded = true;
            resolve();
          };
          img.onerror = () => {
            // Fallback to a placeholder color
            pixel.imageData = [100, 150, 200, 255];
            pixel.loaded = true;
            resolve();
          };
          img.src = pixel.user.profileImageUrl;
        });
      });

      return Promise.all(loadPromises);
    }

    // ============ Rendering ============
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      draw();
    }

    function draw() {
      ctx.fillStyle = '#0f0f0f';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.scale(scale, scale);
      ctx.translate(panX, panY);
      ctx.translate(-GRID_SIZE / 2, -GRID_SIZE / 2);

      ctx.drawImage(offscreen, 0, 0, GRID_SIZE, GRID_SIZE);

      ctx.restore();
      updateInfo();
    }

    function updateInfo() {
      const pixelCountEl = document.getElementById('pixel-count');
      const loadedUsersEl = document.getElementById('loaded-users');
      const lastUpdatedEl = document.getElementById('last-updated');

      pixelCountEl.textContent = `Pixels: ${drawnPixelCount} / ${totalPixels}`;
      loadedUsersEl.textContent = `Users: ${users.length}`;
      if (lastUpdated) {
        lastUpdatedEl.textContent = `Updated: ${lastUpdated}`;
      }
    }

    // ============ Animation Loop ============
    function animate(currentTime) {
      const deltaTime = (currentTime - lastFrameTime) / 1000;
      lastFrameTime = currentTime;

      const pixelsThisFrame = Math.min(
        Math.floor(deltaTime * ANIMATION_SPEED),
        totalPixels - drawnPixelCount
      );

      if (pixelsThisFrame > 0) {
        let imageData = offscreenCtx.getImageData(0, 0, GRID_SIZE, GRID_SIZE);
        const data = imageData.data;

        for (let i = 0; i < pixelsThisFrame; i++) {
          const pixel = pixelList[drawnPixelCount + i];
          if (pixel && pixel.imageData && pixel.imageData.length >= 4) {
            const pixelIndex = (pixel.y * GRID_SIZE + pixel.x) * 4;
            if (pixelIndex + 3 < data.length) {
              data[pixelIndex] = pixel.imageData[0];
              data[pixelIndex + 1] = pixel.imageData[1];
              data[pixelIndex + 2] = pixel.imageData[2];
              data[pixelIndex + 3] = 255;
            }
          }
        }

        offscreenCtx.putImageData(imageData, 0, 0);
        drawnPixelCount += pixelsThisFrame;
      }

      draw();

      if (drawnPixelCount < totalPixels) {
        requestAnimationFrame(animate);
      } else {
        isAnimating = false;
      }
    }

    // ============ Data Loading ============
    async function loadData() {
      try {
        console.log('Starting to load data.json...');
        
        const response = await fetch('./data.json');
        console.log('Fetch response status:', response.status, response.ok);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: Failed to load data.json`);
        }

        const text = await response.text();
        console.log('Response text received, length:', text.length);
        
        const data = JSON.parse(text);
        console.log('JSON parsed successfully');
        console.log('Data structure:', Object.keys(data));
        
        users = data.users || [];
        lastUpdated = data.lastUpdated;

        console.log(`Loaded ${users.length} users`);

        if (users.length > 0) {
          generatePixelPositions(Math.min(users.length, data.maxPixels || 1000000));
          console.log('Loading user images...');
          
          await loadUserImages();
          console.log('All images loaded');

          isAnimating = true;
          lastFrameTime = performance.now();
          requestAnimationFrame(animate);
          return; // Success!
        } else {
          throw new Error('No users found in data.json');
        }
      } catch (error) {
        console.error('❌ Error loading data:', error);
        console.error('Error message:', error.message);
        
        // Show detailed error to user
        const errorMsg = `Error: ${error.message} (Check console for details)`;
        document.getElementById('pixel-count').textContent = errorMsg;
        
        // Try to load from embedded fallback
        console.warn('Attempting to load from embedded fallback data...');
        loadFallbackData();
      }
    }

    // ============ Fallback Data ============
    function loadFallbackData() {
      try {
        const fallbackData = {
          "lastUpdated": "2026-01-09",
          "maxPixels": 1000000,
          "users": [
            {
              "username": "demo_user_1",
              "profileImageUrl": "https://api.dicebear.com/7.x/avataaars/svg?seed=user1",
              "profileUrl": "https://instagram.com/demo_user_1"
            },
            {
              "username": "demo_user_2",
              "profileImageUrl": "https://api.dicebear.com/7.x/avataaars/svg?seed=user2",
              "profileUrl": "https://instagram.com/demo_user_2"
            },
            {
              "username": "demo_user_3",
              "profileImageUrl": "https://api.dicebear.com/7.x/avataaars/svg?seed=user3",
              "profileUrl": "https://instagram.com/demo_user_3"
            },
            {
              "username": "demo_user_4",
              "profileImageUrl": "https://api.dicebear.com/7.x/avataaars/svg?seed=user4",
              "profileUrl": "https://instagram.com/demo_user_4"
            },
            {
              "username": "demo_user_5",
              "profileImageUrl": "https://api.dicebear.com/7.x/avataaars/svg?seed=user5",
              "profileUrl": "https://instagram.com/demo_user_5"
            }
          ]
        };

        users = fallbackData.users;
        lastUpdated = fallbackData.lastUpdated + ' (fallback)';
        
        console.log('✅ Loaded fallback data with', users.length, 'users');
        
        generatePixelPositions(Math.min(users.length, fallbackData.maxPixels));
        
        loadUserImages().then(() => {
          console.log('Fallback data ready');
          isAnimating = true;
          lastFrameTime = performance.now();
          requestAnimationFrame(animate);
          document.getElementById('pixel-count').textContent = 'Demo Mode (Fallback Data)';
        });
        
      } catch (error) {
        console.error('❌ Fallback also failed:', error);
        document.getElementById('pixel-count').textContent = 'Unable to load data (see console)';
      }
    }

    // ============ Input Handling ============
    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      canvas.style.cursor = 'grabbing';
    });

    window.addEventListener('mouseup', () => {
      isDragging = false;
      canvas.style.cursor = 'grab';
    });

    window.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const deltaX = e.clientX - dragStartX;
        const deltaY = e.clientY - dragStartY;

        panX += deltaX / scale;
        panY += deltaY / scale;

        dragStartX = e.clientX;
        dragStartY = e.clientY;

        draw();
      }

      // Hover detection
      const rect = canvas.getBoundingClientRect();
      const canvasX = e.clientX - rect.left;
      const canvasY = e.clientY - rect.top;

      // Convert canvas coordinates to grid coordinates
      const worldX = (canvasX - canvas.width / 2) / scale - panX;
      const worldY = (canvasY - canvas.height / 2) / scale - panY;
      const gridX = worldX + GRID_SIZE / 2;
      const gridY = worldY + GRID_SIZE / 2;

      const pixelX = Math.floor(gridX);
      const pixelY = Math.floor(gridY);

      if (pixelX >= 0 && pixelX < GRID_SIZE && pixelY >= 0 && pixelY < GRID_SIZE) {
        const key = `${pixelX},${pixelY}`;
        const user = pixelMap.get(key);

        if (user) {
          const hoverInfo = document.getElementById('hover-info');
          hoverInfo.textContent = `@${user.username}`;
          hoverInfo.style.display = 'block';
          hoverInfo.style.left = (e.clientX + 10) + 'px';
          hoverInfo.style.top = (e.clientY + 10) + 'px';
          canvas.style.cursor = 'pointer';
        } else {
          document.getElementById('hover-info').style.display = 'none';
          canvas.style.cursor = 'grab';
        }
      } else {
        document.getElementById('hover-info').style.display = 'none';
        canvas.style.cursor = 'grab';
      }
    });

    canvas.addEventListener('click', (e) => {
      if (isDragging) return;

      const rect = canvas.getBoundingClientRect();
      const canvasX = e.clientX - rect.left;
      const canvasY = e.clientY - rect.top;

      const worldX = (canvasX - canvas.width / 2) / scale - panX;
      const worldY = (canvasY - canvas.height / 2) / scale - panY;
      const gridX = worldX + GRID_SIZE / 2;
      const gridY = worldY + GRID_SIZE / 2;

      const pixelX = Math.floor(gridX);
      const pixelY = Math.floor(gridY);

      if (pixelX >= 0 && pixelX < GRID_SIZE && pixelY >= 0 && pixelY < GRID_SIZE) {
        const key = `${pixelX},${pixelY}`;
        const user = pixelMap.get(key);

        if (user && user.profileUrl) {
          window.open(user.profileUrl, '_blank');
        }
      }
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();

      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.width / 2;
      const mouseY = e.clientY - rect.height / 2;

      const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
      const oldScale = scale;
      scale *= zoomFactor;

      panX += mouseX / oldScale - mouseX / scale;
      panY += mouseY / oldScale - mouseY / scale;

      draw();
    });

    window.addEventListener('resize', resizeCanvas);

    // ============ Initialization ============
    resizeCanvas();
    loadData();
  </script>
</body>
</html>
