<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>1M Follower Pixels</title>
<style>
  html, body {
    margin: 0;
    background: #0f0f0f;
    overflow: hidden;
  }
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    margin: 0;
  }
  canvas {
    display: block;
    image-rendering: pixelated;
    cursor: grab;
  }
  #canvas {
    border: 1px solid #000;
  }
  #info {
    position: fixed;
    top: 10px;
    left: 10px;
    color: #ccc;
    font-family: monospace;
    font-size: 14px;
  }
  #social-links {
    margin-top: 20px;
  }
</style>
</head>
<body>

<h1>1M Follower Pixels</h1>
<div id="social-links">
  <a href="#">Facebook</a>
  <a href="#">Twitter</a>
  <a href="#">Instagram</a>
</div>
<canvas id="canvas"></canvas>
<div id="info"></div>

<script>
const SIZE = 1000;
const ANIMATION_SPEED = 50000; // pixels per second

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const offscreen = document.createElement('canvas');
offscreen.width = SIZE;
offscreen.height = SIZE;
const offscreenCtx = offscreen.getContext('2d');
let imageData = offscreenCtx.createImageData(SIZE, SIZE);

let scale = 1;
let offsetX = 0;
let offsetY = 0;
let dragging = false;
let lastX, lastY;

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  draw();
}
window.addEventListener("resize", resize);

function hslToRgb(h, s, l) {
  h /= 360;
  s /= 100;
  l /= 100;
  const c = (1 - Math.abs(2 * l - 1)) * s;
  const x = c * (1 - Math.abs((h * 6) % 2 - 1));
  const m = l - c / 2;
  let r, g, b;
  if (0 <= h && h < 1/6) { r = c; g = x; b = 0; }
  else if (1/6 <= h && h < 2/6) { r = x; g = c; b = 0; }
  else if (2/6 <= h && h < 3/6) { r = 0; g = c; b = x; }
  else if (3/6 <= h && h < 4/6) { r = 0; g = x; b = c; }
  else if (4/6 <= h && h < 5/6) { r = x; g = 0; b = c; }
  else { r = c; g = 0; b = x; }
  return [Math.round((r + m) * 255), Math.round((g + m) * 255), Math.round((b + m) * 255)];
}

let targetPixels = 0;
let drawnPixels = 0;
let pixelList = [];


fetch("data.json")
  .then(r => r.json())
  .then(data => {
    const today = new Date().toISOString().split("T")[0];
    const dates = Object.keys(data.followersByDay).sort();
    let followers = 0;

    for (const d of dates) {
      if (d <= today) followers = data.followersByDay[d];
    }

    targetPixels = Math.min(followers, SIZE * SIZE);
    generatePixels(targetPixels);
    resize();
    animate();
  });

function generatePixels(count) {
  const rng = mulberry32(123456);
  const used = new Set();

  while (pixelList.length < count) {
    const x = Math.floor(rng() * SIZE);
    const y = Math.floor(rng() * SIZE);
    const key = x + "," + y;
    if (used.has(key)) continue;

    used.add(key);
    const h = Math.floor(rng() * 360);
    const [r, g, b] = hslToRgb(h, 100, 60);
    pixelList.push({
      x,
      y,
      r,
      g,
      b
    });
  }
}

function draw() {
  ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
  ctx.clearRect(-offsetX / scale, -offsetY / scale, canvas.width / scale, canvas.height / scale);

  ctx.drawImage(offscreen, 0, 0);

  document.getElementById("info").textContent =
    `Pixels: ${drawnPixels} / 1 Million`;
}

let lastTime = performance.now();

function animate(time = performance.now()) {
  const delta = (time - lastTime) / 1000;
  lastTime = time;

  const newPixels = Math.min(
    Math.floor(delta * ANIMATION_SPEED),
    targetPixels - drawnPixels
  );

  for (let i = 0; i < newPixels; i++) {
    const p = pixelList[drawnPixels + i];
    const index = (p.y * SIZE + p.x) * 4;
    imageData.data[index] = p.r;
    imageData.data[index + 1] = p.g;
    imageData.data[index + 2] = p.b;
    imageData.data[index + 3] = 255;
  }

  if (newPixels > 0) {
    offscreenCtx.putImageData(imageData, 0, 0);
  }

  drawnPixels += newPixels;

  draw();
  requestAnimationFrame(animate);
}

canvas.addEventListener("mousedown", e => {
  dragging = true;
  lastX = e.clientX;
  lastY = e.clientY;
  canvas.style.cursor = "grabbing";
});

window.addEventListener("mouseup", () => {
  dragging = false;
  canvas.style.cursor = "grab";
});

window.addEventListener("mousemove", e => {
  if (!dragging) return;
  offsetX += e.clientX - lastX;
  offsetY += e.clientY - lastY;
  lastX = e.clientX;
  lastY = e.clientY;
  draw();
});

canvas.addEventListener("wheel", e => {
  const zoom = e.deltaY < 0 ? 1.1 : 0.9;
  scale *= zoom;
  draw();
});
</script>

</body>
</html>
