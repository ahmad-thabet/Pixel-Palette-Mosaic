<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>1M Follower Pixels</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      background: #0f0f0f;
      overflow: hidden;
      font-family: monospace;
    }

    #canvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      cursor: grab;
      touch-action: none;
    }

    #canvas:active {
      cursor: grabbing;
    }

    #info {
      position: fixed;
      top: 12px;
      left: 12px;
      background: rgba(0, 0, 0, 0.7);
      color: #0f0;
      padding: 8px 12px;
      border: 1px solid #0f0;
      font-size: 12px;
      line-height: 1.4;
      pointer-events: none;
      z-index: 100;
    }

    #controls {
      position: fixed;
      bottom: 12px;
      right: 12px;
      background: rgba(0, 0, 0, 0.7);
      color: #0f0;
      padding: 8px 12px;
      border: 1px solid #0f0;
      font-size: 11px;
      pointer-events: none;
    }

    .loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #0f0;
      font-size: 14px;
      text-align: center;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="info">
    <div id="pixel-count">Loading...</div>
    <div id="follower-date"></div>
  </div>
  <div id="controls">
    <div>Scroll: Zoom | Drag: Pan</div>
  </div>

  <script>
    // ============ Configuration ============
    const GRID_SIZE = 1000;
    const PIXEL_SIZE = 1; // Size of each pixel in the 1000x1000 grid
    const ANIMATION_SPEED = 50000; // Pixels to draw per second
    const SEED = 42; // Consistent seed for deterministic RNG

    // ============ Seeded Random Number Generator ============
    function mulberry32(a) {
      return function() {
        a |= 0;
        a = (a + 0x6d2b79f5) | 0;
        let t = Math.imul(a ^ (a >>> 15), 1 | a);
        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    // ============ Color Conversion ============
    function hslToRgb(h, s, l) {
      h = h % 360;
      s = Math.max(0, Math.min(100, s));
      l = Math.max(0, Math.min(100, l));

      h /= 360;
      s /= 100;
      l /= 100;

      let r, g, b;

      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }

      return [
        Math.round(r * 255),
        Math.round(g * 255),
        Math.round(b * 255),
        255
      ];
    }

    // ============ Canvas Setup ============
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: false });

    // Offscreen canvas for pixel data
    const offscreen = document.createElement('canvas');
    offscreen.width = GRID_SIZE;
    offscreen.height = GRID_SIZE;
    const offscreenCtx = offscreen.getContext('2d');

    // Initialize with transparent pixels
    const imageData = offscreenCtx.createImageData(GRID_SIZE, GRID_SIZE);
    offscreenCtx.putImageData(imageData, 0, 0);

    // ============ State ============
    let targetPixelCount = 0;
    let drawnPixelCount = 0;
    let pixelList = [];
    let isAnimating = false;
    let currentDate = '';

    // View state
    let scale = 1;
    let panX = 0;
    let panY = 0;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;

    // Animation timing
    let lastFrameTime = performance.now();

    // ============ Pixel Generation ============
    function generatePixels(count) {
      const rng = mulberry32(SEED);
      const occupiedSet = new Set();

      pixelList = [];

      for (let i = 0; i < count; i++) {
        let attempts = 0;
        const maxAttempts = 1000;

        while (attempts < maxAttempts) {
          const x = Math.floor(rng() * GRID_SIZE);
          const y = Math.floor(rng() * GRID_SIZE);
          const key = `${x},${y}`;

          if (!occupiedSet.has(key)) {
            occupiedSet.add(key);

            const hue = Math.floor(rng() * 360);
            const saturation = 70 + Math.floor(rng() * 30); // 70-100%
            const lightness = 45 + Math.floor(rng() * 20); // 45-65%
            const [r, g, b, a] = hslToRgb(hue, saturation, lightness);

            pixelList.push({ x, y, r, g, b, a });
            break;
          }

          attempts++;
        }
      }
    }

    // ============ Rendering ============
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      draw();
    }

    function draw() {
      // Clear canvas
      ctx.fillStyle = '#0f0f0f';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Save context state
      ctx.save();

      // Apply view transforms
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.scale(scale, scale);
      ctx.translate(panX, panY);
      ctx.translate(-GRID_SIZE * PIXEL_SIZE / 2, -GRID_SIZE * PIXEL_SIZE / 2);

      // Draw grid
      ctx.drawImage(offscreen, 0, 0, GRID_SIZE * PIXEL_SIZE, GRID_SIZE * PIXEL_SIZE);

      ctx.restore();

      // Update info display
      updateInfo();
    }

    function updateInfo() {
      const pixelCountEl = document.getElementById('pixel-count');
      const followerDateEl = document.getElementById('follower-date');

      const formattedCount = targetPixelCount.toLocaleString();
      pixelCountEl.textContent = `Pixels: ${drawnPixelCount.toLocaleString()} / ${formattedCount} (Target: 1M)`;

      if (currentDate) {
        followerDateEl.textContent = `Date: ${currentDate}`;
      }
    }

    // ============ Animation Loop ============
    function animate(currentTime) {
      const deltaTime = (currentTime - lastFrameTime) / 1000;
      lastFrameTime = currentTime;

      // Calculate how many new pixels to draw this frame
      const pixelsThisFrame = Math.min(
        Math.floor(deltaTime * ANIMATION_SPEED),
        targetPixelCount - drawnPixelCount
      );

      // Draw new pixels to offscreen canvas
      if (pixelsThisFrame > 0) {
        const currentImageData = offscreenCtx.getImageData(0, 0, GRID_SIZE, GRID_SIZE);
        const data = currentImageData.data;

        for (let i = 0; i < pixelsThisFrame; i++) {
          const pixel = pixelList[drawnPixelCount + i];
          const pixelIndex = (pixel.y * GRID_SIZE + pixel.x) * 4;

          data[pixelIndex] = pixel.r;
          data[pixelIndex + 1] = pixel.g;
          data[pixelIndex + 2] = pixel.b;
          data[pixelIndex + 3] = pixel.a;
        }

        offscreenCtx.putImageData(currentImageData, 0, 0);
        drawnPixelCount += pixelsThisFrame;
      }

      draw();

      if (drawnPixelCount < targetPixelCount) {
        requestAnimationFrame(animate);
      } else {
        isAnimating = false;
      }
    }

    // ============ Data Loading ============
    async function loadFollowerData() {
      try {
        // Try multiple fetch approaches
        let data;
        let loaded = false;

        // Approach 1: Try relative path
        try {
          const response = await fetch('./data.json');
          if (response.ok) {
            data = await response.json();
            loaded = true;
            console.log('Successfully loaded data.json from ./data.json');
          }
        } catch (e) {
          console.log('Failed to load from ./data.json:', e);
        }

        // Approach 2: Try absolute path from root
        if (!loaded) {
          try {
            const response = await fetch('/data.json');
            if (response.ok) {
              data = await response.json();
              loaded = true;
              console.log('Successfully loaded data.json from /data.json');
            }
          } catch (e) {
            console.log('Failed to load from /data.json:', e);
          }
        }

        if (loaded && data) {
          const today = new Date().toISOString().split('T')[0];
          currentDate = today;

          // Find the latest follower count <= today
          const dates = Object.keys(data.followersByDay).sort();
          let followerCount = 0;

          for (const date of dates) {
            if (date <= today) {
              followerCount = data.followersByDay[date];
            } else {
              break;
            }
          }

          console.log(`Loaded follower count for ${today}: ${followerCount}`);

          targetPixelCount = Math.min(followerCount, GRID_SIZE * GRID_SIZE);

          // Generate pixels deterministically
          generatePixels(targetPixelCount);

          // Start animation
          isAnimating = true;
          lastFrameTime = performance.now();
          requestAnimationFrame(animate);
          return;
        }

      } catch (error) {
        console.error('Error loading data:', error);
      }

      // Fallback: Use embedded demo data
      console.warn('Using fallback demo data');
      const fallbackData = {
        "startDate": "2026-01-01",
        "followersByDay": {
          "2026-01-01": 0,
          "2026-01-02": 10,
          "2026-01-03": 1000,
          "2026-01-04": 244834,
          "2026-01-05": 142766,
          "2026-01-06": 391869,
          "2026-01-07": 692772,
          "2026-01-08": 804344,
          "2026-01-09": 1000000
        }
      };

      const today = new Date().toISOString().split('T')[0];
      currentDate = today;

      const dates = Object.keys(fallbackData.followersByDay).sort();
      let followerCount = 0;

      for (const date of dates) {
        if (date <= today) {
          followerCount = fallbackData.followersByDay[date];
        } else {
          break;
        }
      }

      targetPixelCount = Math.min(followerCount, GRID_SIZE * GRID_SIZE);
      generatePixels(targetPixelCount);

      isAnimating = true;
      lastFrameTime = performance.now();
      requestAnimationFrame(animate);
    }

    // ============ Input Handling ============
    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      canvas.style.cursor = 'grabbing';
    });

    window.addEventListener('mouseup', () => {
      isDragging = false;
      canvas.style.cursor = 'grab';
    });

    window.addEventListener('mousemove', (e) => {
      if (!isDragging) return;

      const deltaX = e.clientX - dragStartX;
      const deltaY = e.clientY - dragStartY;

      panX += deltaX / scale;
      panY += deltaY / scale;

      dragStartX = e.clientX;
      dragStartY = e.clientY;

      draw();
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();

      // Zoom towards mouse position
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.width / 2;
      const mouseY = e.clientY - rect.height / 2;

      const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
      const oldScale = scale;
      scale *= zoomFactor;

      // Adjust pan to zoom towards cursor
      panX += mouseX / oldScale - mouseX / scale;
      panY += mouseY / oldScale - mouseY / scale;

      draw();
    });

    window.addEventListener('resize', resizeCanvas);

    // ============ Initialization ============
    resizeCanvas();
    loadFollowerData();
  </script>
</body>
</html>
